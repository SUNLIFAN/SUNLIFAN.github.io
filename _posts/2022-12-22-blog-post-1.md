---
title: 'Intro to Database System : Concurrency Control'
date: 2022-12-22
permalink: /posts/2022/12/15445-15
tags:
  - computer science
  - database
---

## Content

1. Motivation

2. Transactions

3. Definitions

4. ACID: Atomicity

5. ACID: Consistency

6. ACID: Isolation

7. ACID: Durability

## Motivation

到目前为止，我们从最底层的 access method, 到最高层的 query plan 都已经讨论过了，在正常情况下 DBMS 已经可以正常运转，但是现实场景中往往会出现一些异常情况，考虑如下的情况:

- 两个线程同时对一张表中的同一个元组进行了修改，此时出现了 race condition，要如何处理?

- 我们需要从银行账户 A 向账户 B 转账 1000 元，如果我们从 A 取出 1000 之后，在向 B 转入 1000 之前，系统崩溃了怎么办? 

上述两个场景分别是丢失修改和持久性问题，要解决这两个问题需要对并发控制 (Concurrency control) 和恢复 (Recovery) 做更加深入的讨论，而前者正是本节的主题。

并发控制和恢复是 DBMS 非常重要的性质，有了它们，应用程序员在开发应用程序时只需要专注于业务逻辑，而不需要编写晦涩的代码来保证不出现并发问题，这是 DBMS 的职责。

DBMS 的并发控制和恢复都是基于具有 ACID 性质的事务的，下面会详述 ACID 和事务的概念。

## Transactions

事务 (Transaction) 是一系列 SQL 语句，一起完成一个高级层面的任务，事务是 DBMS 中修改发生的最小单元。举例来说，从账户 A 转账 1000 元到账户 B 就是一个事务，它包含三个操作：检查 A 是否有大于等于 1000 元余额，扣除 A 1000 元，增加 B 1000 元。这三件事要不然全部完成，要不然一件都不完成。

### Strawman System

一种简单粗暴的实现 DBMS 对事务的支持的方式是，使用一个 worker 线程来处理事务，多个事务按照串行方式执行。每个事务的执行方式是，先对文件做一份拷贝，在拷贝上修改，修改完成之后把指向文件最新版本的指针指向这个修改后的版本，如果失败了，只需要丢弃刚刚修改的拷贝。这种方法以简单的方式实现了对事务的支持，但是缺点是效率比较低，当数据量大的时候消耗的时间将让人无法接受。

同时，事务串行执行的限制也限制了系统的效率，我们希望能让事务并发执行，以提高硬件的利用率。但是我们同时需要保证的是: 正确性，（最好还要有）公平性。这意味着我们不能进行任意的并发执行，因为这将带来两个问题:

- 暂时的不一致性 (比如银行转账事务中从 A 中扣钱但是尚未向 B 中汇入钱的状态)，这是不可避免的。

- 永久的不一致性（由于不好的调度带来的不一致状态），这是我们需要避免的。

因此，我们需要一个正确性标准，来决定一个调度是否是正确的。

## Definitions

一个事务一般包括多个从数据库中读取数据，向数据库中写入数据。DBMS 只关心对数据的读写操作，至于发生在外部的事并不关心。有了这个前提，我们可以给出更加形式化的定义。

### Formal Definition

Database: 一个固定大小的数据集合 (eg. A, B, C, D ...)，我们不需要知道数据的语义内容，同时，在本次我们假定数据库大小固定，这意味着我们不考虑插入和删除操作，这将在之后讨论。

Transaction: 一个读写操作的序列，例如: R(A), W(A), R(B), W(B)...，这是 DBMS 对应用程序的抽象视角。

### Transactions in SQL

在 SQL 中，事务以 begin 关键字开启，以 commit 或者 abort/rollback 结束，commit 可能引发保存数据或者 abort，abort 则会回滚数据。

### Correctness Criteria: ACID

前面提及到 DBMS 的并发控制和恢复都是基于具有 ACID 性质的事务，因此 ACID 性质就是一种可行的正确性标准。

Atomicity: 事务中所有操作要么全做，要么一个都不做。

Consistency: 可以看做一种保持性质，一系列事务会使得一个数据库从一个一致性状态转移到另一个一致性状态。这里的一致性是逻辑上的正确性，由于脱离了具体的语义，难以明确的说明。

Isolation: 并发的事务之间不相互影响。

Durability: 一个事务一旦提交，它的影响是持久的。

## ACID: Atomicity

DBMS 保证事务原子性有两种方法:

Approach #1: Logging，这种方法在事务进行的同时在内存和磁盘维护一份日志，记录每次操作的信息，在事务 abort 的时候可以进行 undo 操作，可以把它的作用看成飞机的黑盒子。

Approach #2: Shadow Paging，这种方法是之前提到的 strawman system 中使用的方法的改进，不同的是它对要修改的 page 做拷贝，而不是整个文件。

目前大部分的 DBMS 都使用日志的方法，因为它记录了更多有用的信息，而 shadow paging 在系统崩溃之后，我们无法知道到底发生了什么。

## ACID: Consistency

一致性衡量数据库建模的这个世界是否在逻辑上正确。所有查询应该给出逻辑上正确的结果，这里的正确性和具体语义有关。

一致性包含数据库一致性和事务一致性。

### Database Consistency

数据库一致性意味着数据库正确地建模现实世界，并满足限制 (constraint)，数据库一致性意味着未来的事务将会看到现在已经提交的事务产生的效果。

### Transaction Consistency

如果数据库开始于一个一致性状态，那么事务结束之后将仍然处于一致性状态。事务一致性是应用程序的职责，DBMS 无法控制。因此，之后讨论的一致性都是数据库一致性。

## Isolation of Transactions

要保证事务之间的隔离，就是要在让事务并发执行的同时，让外部看起来系统是在串行地执行事务。

### Mechanism for ensuring isolation

保证隔离性的方法是指定一个并发控制协议。一个并发控制协议定义了 DBMS 如何调度多个事务。

并发控制协议有两种类型:

- Optimistic: 假定问题很少发生，在执行后如果发现问题再回滚。

- Pessimistic: 从开始就避免问题发生。

并发执行多个事务意味着交错执行多个事务中的操作，执行这些操作的顺序称为执行调度，我们想要在最大化效率的同时保证正确性，并发控制协议的目标是生成一个正确的执行调度。

### Formal Properties of Schedule

Serial Schedule: 串行执行的调度，事务不并发执行。

Equivalent Schedule: 对于一个数据库状态，如果第一个调度和第二个调度执行完之后到达同一个数据库状态，那么称两个调度等价。

Serializable Schedule: 如果一个调度等价于一个串行调度，那么称这个调度为可串行化调度。

Conflict: 如果两个操作分别属于两个事务，且两个操作对同一个数据库对象进行，且至少有一个操作是写操作，则称两个操作是冲突的。

根据上述定义，冲突有以下的三种:

- Read-Write conflict (不可重复读): 一个事务内两次对同一个对象的读操作产生了不同的值。

- Write-Read conflict (脏读): 一个事务读取了另一个事务修改但是还没提交的脏值。

- Write-Write conflict (丢失修改): 一个事务覆盖了另一个还未提交的事务的还未提交的值。

有了上述的定义，我们知道一个调度是可串行化的意味着什么，因此我们可以检查一个调度是否是可串行化的。

可串行化有不同的等级: Conflict Serializable，View Serializable，DBMS 通常支持前者，因为有比较高效的实现。

### Conflict Serializable

如果两个调度包含相同事务的相同操作，且冲突的操作的顺序相同，那么称两个调度为冲突等价。

如果一个调度和一个串行调度冲突等价，那么称这个调度为冲突可串行化调度。一个冲突可串行化调度可以通过交换相邻的非冲突操作转化为串行调度。

这为我们提供了一个检查冲突可串行化的简单的算法，但是交换操作对于两个事务来说是简单的，如果有多个事务，那么这个方法就有点笨拙了。一种更加高效的方法是依赖 dependency graph.

### Dependency Graph

依赖图是一个有向图，图上每个节点代表一个事务，如果调度 S 中，事务 i 中某个操作 $O_i$ 和事务 j 中某个操作 $O_j$ 冲突，且前者在调度 S 中更早出现，那么存在一条边 $T_i \to T_j$. 如果一个调度 S 的依赖图是无环图，那么调度 S 是冲突可串行化的。

这样就把问题转化为对有向图上是否有环的判断，有许多图论算法可用，例如直接 DFS 就可以在线性时间内判断有没有环。

## ACID: Durability

前面提到过保证原子性的做法，保证持久性也可以用这两种做法。

有了日志在系统崩溃后可以 redo，而在 shadow paging 中我们认为 flip 指向最新版本的指针的操作是原子性的，因此也可以保证改变的持久性。

## Conclusion

并发控制和恢复可以说是 DBMS 最重要的两个功能，DBMS 自动地支持这两个功能，为应用程序员节省了繁重的工作。DBMS 自动插入 lock 和 unlock 操作，让调度等价于某个串行调度。