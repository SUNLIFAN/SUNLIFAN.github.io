---
title: 'Object Orientation Design: Principles'
date: 2023-03-06
permalink: /posts/2023/03/ood-01
tags:
  - software engineering
  - OOD
---
## Content

1. Introduction

2. Single Responsibility Principle

3. Open-Closed Principle

4. Liskov Substitution Principle

5. Dependency Inversion Principle

6. Interface Segregation Principle

7. Composite Reuse Principle

8. Law of Demeter

## Introduction

自顶向下的软件设计过程: 需求 -> 规约 -> 架构 -> 设计

其中需求定义了软件的高层次目标；规约定义了系统的外部可观察到的行为，是对需求的形式化描述；架构定义了系统层级的组件、组件之间的交互方式以及使用的技术，从高层次描述了系统的设计；(详细) 设计定义了如何完成任务，需要如何完成编程，是对架构中各个部分的进一步精化。在软件系统设计这门课的前半部分中，关注的是设计环节，特别地，主要关注面向对象设计 (OOD).

OOD 是将实现约束应用到面向对象分析所产生的概念模型的过程，一般要经过以下几步: 用方法和属性来描述构成系统的类 -> 添加不明显属于领域的类，比如接口、抽象类、工具类等 -> 描述类是如何构成组件的。

![](https://github.com/tiebreaker4869/images/blob/main/post/ood011.png?raw=true)

> OOD 所处的环节

OOD 的难点在于如何发现组成系统组件的类，一般有以下三个来源:

- 直接来自于分析模型，这一般是容易发现的。

- 来自实现空间，比如一些工具类

- 为了设计而添加的类，比如使用策略模式时需要添加策略抽象类等。

从 OOA 到 OOD 没有什么可以直接参照的流程，一般需要靠设计者的经验，但是 OOD 中的一些原则是普适的。

软件设计的目标是提高软件系统的可维护性和可复用性，下面介绍软件设计的七个原则，它们相互依赖，互相补充。

![](https://github.com/tiebreaker4869/images/blob/main/post/ood012.png?raw=true)

> 软件设计原则概览

## Single Responsibility Principle

### 定义

单一职责原则的定义是一个对象只应该拥有一个单一的职责，且这个职责应该被完整的封装在一个类中。

> 这里的职责有着某种 minimal 的意味，我认为应该指的是某个在逻辑上完整且独立的功能。

另一种定义方式是: 一个类只应该有一个变化的原因。

> 这里我是从需求变更的角度理解，一个类发生变更的原因只应该是它对应的这个职责对应的需求发生变化，而不是被其他的变更牵动。

### 分析

单一职责原则基于这样的想法: 一个类的职责越多，那么它被复用的可能性就越低，并且当一个类拥有过多的职责时，这些职责可能会相互耦合，互相影响。

一个类的职责主要体现在两个方面: 数据职责和行为职责，这也体现了信息隐藏的原则，对数据结构的操作和数据结构存储的数据应该被封装在一起。

单一职责原则是 OOD 中的一个基本原则，是实现 **高内聚、低耦合** 的指导方针，它在叙述上很简单，但是实践起来往往是有难度的，因为如何切分职责需要设计人员有较强的分析能力和经验。


![](https://github.com/tiebreaker4869/images/blob/main/post/ood013.png?raw=true)

## Open-Closed Principle

### 定义

开闭原则的定义是: **一个软件实体应当对扩展开放，而对修改封闭**。具体来说，一个软件实体应该在只需要添加源代码，而不需要修改原有的源代码的前提下实现功能的扩展，这就是开闭原则。其中，一个软件实体可以指一个模块，多个类组成的局部，或者某个类。

### 分析

抽象化是实现开闭原则的关键；开闭原则还可以用一个更加具体的 "可变性封装" 原则来描述: 识别出系统的可变部分，并封装起来。

![](https://github.com/tiebreaker4869/images/blob/main/post/ood019.png?raw=true)

## Liskov Substitution Principle

### 定义

里氏代换原则的定义: 所有能够使用基类对象的地方都要能够透明地替换成子类对象，也就是，替换成子类对象后程序的行为不改变。

### 分析

里氏代换原则要求 **能用父类引用的地方都需要能够透明地替换为子类**，这意味着如果把一个地方的父类对象改成子类对象，程序不会产生任何错误或者异常。

里氏代换原则是实现开闭原则的重要原则之一，由于所有引用基类的地方都可以替换成子类，最好在程序中定义对象时都采用基类对象，在运行时再确定子类类型。

![](https://github.com/tiebreaker4869/images/blob/main/post/ood014.png?raw=true)

## Dependency Inversion Principle

### 定义

依赖倒转原则的定义: 高层模块不应该依赖于低层模块，它们都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。依赖倒转原则的另一种表述是我们所熟知的: 面向接口编程而不是面向实现。

### 分析

具体来说，就是在代码中应该尽可能依赖抽象类或者接口，而不是具体类。依赖倒转一种常见的实现方式是: 在代码中使用抽象类，把具体类放进配置文件。(比如在配置文件中指定类名等信息，在运行时通过反射来创建对象)

> Put abstractions in code, details in metadata

在 OO 程序中，类之间的耦合关系有三种: 零耦合，抽象耦合，具体耦合。由于 OO 程序本身就要依赖于对象和对象之间的交互，因此完全的零耦合是不现实也是无意义的，只能希望把类之间的耦合关系变为抽象耦合。

> 一个具体的例子是在实现三层架构时常常会在表现层和业务层，业务层和数据层之间加上一个抽象层，使得表现层，逻辑层，数据层都依赖于抽象的接口。

依赖倒转原则要求客户端依赖于抽象耦合，以抽象方式耦合是实现依赖倒转的关键。而实现开闭原则的关键是抽象化，因此依赖倒转是实现开闭原则的主要手段。

![](https://github.com/tiebreaker4869/images/blob/main/post/ood015.png?raw=true)

## Interface Segregation Principle

### 定义

接口隔离原则的定义是: 客户端不应该依赖那些它不需要的接口。另一种更具体的定义是: 当一个接口太宽时，应该将它分成若干更窄的接口，客户端仅需要直到那些自己需要的接口。(这里的接口指的是 方法)

### 分析

接口隔离原则是指 **使用多个专门的接口 ，而不使用单一的总接口**。

- 每个接口都要 **代表一个相应的角色**，因此又称为 "角色隔离原则"

- 接口 **仅需要暴露出客户端应该知道的信息，不暴露其他细节**，其他客户端的存在应该是透明的。


在拆分接口的时候，首先要满足单一职责原则，然后在满足高内聚的情况下接口越小越好。

![](https://github.com/tiebreaker4869/images/blob/main/post/ood016.png?raw=true)

## Composite Reuse Principle

### 定义

合成复用原则的定义：优先使用组合来复用，而不是继承。

### 分析

合成复用原则是指在一个对象中使用关联关系 (**组合或者聚合**) 来使用一些已有的对象，使之称为新对象的一部分；新对象通过 **委派调用已有对象的方法** 来实现复用。简而言之就是要多用组合少用继承。

通过继承关系实现的复用是静态的，在运行时难以改变，通过组合关系实现的复用更加灵活，可以在运行时动态配置。（通过更换关联的对象）

由于组合关系是黑盒复用，因此修改对其他类的影响较小，在考虑复用的时候应该优先考虑组合而不是继承；使用继承的时候要严格遵守里氏代换原则。

![](https://github.com/tiebreaker4869/images/blob/main/post/ood017.png?raw=true)

## Law of Demeter

### 定义

迪米特法则，又称最小知识原则，有多种定义方式:

- 不要和 "陌生人" 说话

- 只和你的直接朋友通信

- 每个软件单位都对其他单位有最少的知识，且仅局限于那些和自己密切相关的单位

简单来说，迪米特法则要求一个软件模块尽可能少地和其他软件模块发生相互作用，对通信的深度和广度做了限制。但是 OO 程序实际上又依赖于对象之间的交互，所以迪米特法则只能说是一个指导性的原则，无法完全做到。

进一步地，在上面的定义中仍使用了不少模糊的词语，比如: 直接朋友，下面来定义什么是一个直接朋友

- this 对象

- 通过方法参数传入的对象

- 成员对象

- 类的方法中创建的对象

- 成员对象如果是集合，集合中每个都是直接朋友

满足以上条件之一就是直接朋友，其余都是陌生人。

### 分析

迪米特法则可以分为狭义法则和广义法则，在狭义的迪米特法则中，如果两个类不必直接通信，那么这两个类就不应该发生相互作用，如果要调用方法，应该委托另一个中间类。

广义的迪米特法则指: **对对象之间的信息流量、流向以及信息的影响的控制，主要是对信息隐藏的控制**。信息的隐藏可以使各个子系统之间脱耦，从而允许它们独立地被开发、优化、使用和修改，同时可以促进软件的复用，由于每一个模块都不依赖于其他模块而存在，因此每一个模块都可以独立地在其他的地方使用。一个系统的规模越大，信息的隐藏就越重要，而信息隐藏的重要性也就越明显。

![](https://github.com/tiebreaker4869/images/blob/main/post/ood018.png?raw=true)

## Summary

面向对象设计的目标是设计出可维护，可复用的软件，以以下的原则为指导:

- 单一职责原则要求一个类指承担一个功能领域中的相应职责。

- 开闭原则要求软件模块对扩展开放，对修改关闭，在不修改源代码的情况下扩展软件的行为。

- 里氏代换原则通俗表示为一个能用基类对象的地方应该能够透明地换成子类对象

- 接口隔离原则表述为客户端不应该依赖那些它们不需要的接口，因此接口应该尽量细化

- 依赖倒置原则要求上层模块不应该依赖于底层模块，它们都应该依赖于抽象，细节应该依赖于抽象而不是反过来。

- 合成复用原则说的是尽量使用组合而非继承

- 迪米特法则要求软件实体时间尽可能少地发生相互作用

## Summary Again

- 目标：开闭原则

- 指导：最小知识原则

- 基础：单一职责原则、可变性封装原则

- 实现：依赖倒转原则、合成复用原则、里氏代换原则、接口隔离原则